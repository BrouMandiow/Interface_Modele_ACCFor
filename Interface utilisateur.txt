#Interface utilisateur

#Pour créer un programme R qui prend des inputs utilisateur et fournit une valeur prédite d'albédo en utilisant votre modèle, voici les étapes principales :

#1. Prérequis
#- Assurez-vous que le modèle entraîné (par exemple, model) est sauvegardé ou accessible dans votre environnement R.
#- Préparez une interface pour que l'utilisateur puisse fournir les valeurs des variables nécessaires (par exemple, latitude, température, etc.).

#2. Structure de Base
#Voici une structure pour le script R qui intègre une interaction utilisateur :
  
###################################
# Programme : Prédire l'albédo
###################################

# Charger les bibliothèques nécessaires
library(shiny)
library(shinythemes)
library(randomForest)
library(dplyr)

# Définir l'interface utilisateur (UI)
ui <- fluidPage(
  theme = shinytheme("flatly"),
  titlePanel("Prédiction de l'Albédo"),
  
  sidebarLayout(
    sidebarPanel(
      h4("Entrées numériques"),
      numericInput("latitude", "Latitude :", value = 48, step = 0.00000001),  # Accepte les valeurs décimales
      numericInput("nbjr_neige5", "Nombre de jours de neige :", value = 15, step = 1),  # Entiers uniquement
      numericInput("mois", "Mois :", value = 6, step = 1),  # Entiers uniquement
      numericInput("t_18_c", "Température moyenne à 18h °C :", value = 0, step = 0.01),  # Accepte les valeurs décimales
      numericInput("hauteur", "Hauteur (mètres) :", value = 15, step = 1),  # Entiers uniquement
      
      h4("Entrées catégoriques"),
      selectInput(
        "type_eco",
        "Type écologique :",
        choices = c(
          "FE10", "FE11", "FE12", "FE13", "FE14", "FE15", "FE16", "FE20",
          "FE21", "FE22", "FE23", "FE24", "FE25", "FE26", "FE30", "FE31",
          "FE32", "FE32H", "FE35", "FE42", "FE50", "FE51", "FE52", "FE60",
          "FE61", "FE62", "FO14", "FO15", "FO16", "FO18", "FC10", "FC12",
          "MA18R", "MF14", "MF15", "MF16", "MF18", "MJ10", "MJ11", "MJ12",
          "MJ13", "MJ14", "MJ15", "MJ16", "MJ18", "MJ20", "MJ21", "MJ22",
          "MJ23", "MJ24", "MJ25", "MJ26", "MS11", "MS12", "MS14", "MS15",
          "MS18", "MS20", "MS21", "MS22", "MS23", "MS24", "MS25", "MS26",
          "MS40", "MS42", "MS60", "MS61", "MS62", "MS63", "MS64", "MS65",
          "MS66", "RB10", "RB11", "RB12", "RB13", "RB14", "RB15", "RB16",
          "RC38", "RE20", "RE21", "RE22", "RE24", "RE25", "RE37", "RE38",
          "RE39", "RP10", "RP11", "RP12", "RP13", "RP14", "RP15", "RS10",
          "RS11", "RS12", "RS13", "RS14", "RS15", "RS16", "RS18", "RS20",
          "RS21", "RS22", "RS22M", "RS23", "RS24", "RS25", "RS25S", "RS26",
          "RS37", "RS38", "RS39", "RS50", "RS51", "RS52", "RS54", "RS55",
          "TOB9D", "TOB9U", "TOF8U", "unknown"
        )
      ),
      selectInput(
        "co_ter",
        "Code du terrain :",
        choices = c("A", "AF", "AL", "ANT", "DH", "DS", "EAU", "GR", "ILE", "INO", 
                    "LTE", "NF", "NX", "RO", "TNP", "unknown")
      ),
      selectInput(
        "cl_pent",
        "Classe de pente :",
        choices = c("A", "B", "C", "D", "E", "F", "S", "unknown")
      ),
      selectInput(
        "dep_sur",
        "Dépôt de surface :",
        choices = c(
          "1A", "1AA", "1AB", "1AD", "1AM", "1AY", "1BF", "1BI", "1BP", "1BC",
          "1BG", "1BD", "2A", "2AE", "2AK", "2AT", "2BD", "2BE", "3AC", "3AE",
          "3AN", "3D", "4A", "4GA", "4GD", "4GS", "5A", "5AM", "5AY", "5L",
          "5S", "5SY", "6A", "6S", "6SY", "7E", "7T", "7TM", "7TY", "8A",
          "8AY", "8AM", "8C", "8CM", "8CY", "8E", "8F", "8G", "9S", "9SY",
          "M1A", "M8A", "R", "R1A", "R4G", "R5A", "R5S", "R7T", "R8A", "R8C",
          "unknown"
        )
      ),
      selectInput(
        "cl_drai",
        "Classe de drainage :",
        choices = c(
          "0", "10", "11", "16", "20", "21", "30", "31", "33", "40", "41", 
          "43", "44", "50", "51", "53", "60", "61", "63", "unknown"
        )
      ),
      selectInput(
        "type_couv",
        "Type de couverture :",
        choices = c("F", "M", "R", "unknown")
      ),
      selectInput(
        "cl_dens",
        "Classe de densité :",
        choices = c("A", "B", "C", "D", "H", "unknown")
      ),
      selectInput(
        "cl_haut",
        "Classe de hauteur :",
        choices = c("1", "2", "3", "4", "5", "6", "7", "unknown")
      ),
      selectInput(
        "cl_age",
        "Classe d'âge :",
        choices = c(
          "10", "10JIN", "1050", "1070", "120", "12010", "12030", "12050",
          "12070", "12090", "120JI", "120VI", "120.0", "30", "30.0", "30VIN",
          "3010", "30120", "3030", "3050", "3070", "3090", "5010", "50120",
          "5030", "5050", "5070", "5090", "50", "70", "70.0", "7010", "70120",
          "7030", "7050", "7070", "7090", "90", "90.0", "9010", "90120", "9050",
          "9070", "9090", "JIN", "JIN10", "JIN12", "JIN30", "JIN70", "JIR", 
          "VIN", "VIN10", "VIN12", "VIN30", "VIN50", "VINJI", "VIR", "unknown"
        )
      ),
      actionButton("predict", "Prédire l'Albédo", class = "btn-primary btn-lg btn-block")
    ),
    
    mainPanel(
      h3("Résultats de la Prédiction"),
      wellPanel(textOutput("result"), plotOutput("prediction_plot")),
      h3("Résumé des Données Saisies"),
      wellPanel(tableOutput("input_summary"))
    )
  )
)

# Définir le serveur
server <- function(input, output) {
  # Charger le modèle entraîné
  model_path <- "C:/Users/broum/Downloads/randomForest_model.RData"
  tryCatch({
    load(model_path)
    if (!exists("model")) stop("Erreur : Le modèle n'existe pas dans le fichier.")
  }, error = function(e) {
    stop("Erreur : Impossible de charger le modèle. Vérifiez le chemin et le fichier.")
  })
  
  # Réactifs pour les prédictions et les données d'entrée
  values <- reactiveValues(prediction = NULL, input_data = NULL)
  
  # Réagir au clic sur le bouton "Prédire"
  observeEvent(input$predict, {
    # Vérifier que les données sont cohérentes mais ne rien limiter
    new_data <- data.frame(
      LATITUDE = input$latitude,
      nbjr_neige5 = input$nbjr_neige5,
      mois = input$mois,
      t_18_c = input$t_18_c,
      TYPE_ECO = input$type_eco,
      CO_TER = input$co_ter,
      CL_PENT = input$cl_pent,
      DEP_SUR = input$dep_sur,
      CL_DRAI = input$cl_drai,
      TYPE_COUV = input$type_couv,
      CL_DENS = input$cl_dens,
      CL_HAUT = input$cl_haut,
      CL_AGE = input$cl_age,
      HAUTEUR = input$hauteur
    )
    
    observeEvent(input$predict, {
      if (!is.numeric(input$latitude) || !is.numeric(input$t_18_c)) {
        stop("Les champs 'latitude' et 't_18_c' doivent être des nombres décimaux.")
      }
      if (!is.integer(input$mois) || !is.integer(input$hauteur) || !is.integer(input$nbjr_neige5)) {
        stop("Les champs 'mois', 'hauteur' et 'nbjr_neige5' doivent être des nombres entiers.")
      }
    })
    
    # Aucune modification ou ajustement automatique
    values$input_data <- new_data
    
    tryCatch({
      values$prediction <- predict(model, newdata = new_data)
    }, error = function(e) {
      values$prediction <- "Erreur lors de la prédiction."
    })
  })
  
  # Afficher les résultats de la prédiction
  output$result <- renderText({
    req(values$prediction)  # S'assurer que la prédiction existe
    sprintf("La valeur prédite de l'albédo est : %.3f", values$prediction)
  })
  
  # Afficher un résumé des données saisies
  output$input_summary <- renderTable({
    req(values$input_data)  # S'assurer que les données d'entrée existent
    data.frame(
      Variable = names(values$input_data),
      Valeur = unlist(values$input_data)
    )
  })
  
  # Afficher un graphique de la prédiction
  output$prediction_plot <- renderPlot({
    req(values$prediction)  # S'assurer que la prédiction existe
    plot(
      density(c(0.1, 0.9)),  # Exemple de plage pour l'albédo
      main = "Distribution de l'Albédo Prédit",
      xlab = "Albédo",
      ylab = "Densité"
    )
    abline(v = values$prediction, col = "red", lwd = 2)
    text(values$prediction, 0,
         sprintf("%.3f", values$prediction),
         pos = 4, col = "red")
  })
}

# Lancer l'application
shinyApp(ui = ui, server = server)